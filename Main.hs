-- | This file showcases an example verifying a Plonk BN254 Sphinx proof using FFI
-- |
-- | The Go component is responsible for embedding and calling the Gnark verification code,
-- | and corresponds to the `sphinx/recursion/gnark-ffi/go/` module.
-- |
-- | This depends on two Rust functions, extracted to the `babybear/` directory.
-- |
-- | Verifying the proof requires that the circuit artifacts corresponding to the circuit version
-- | used to generate the proof be present somewhere. These can be auto-installed by Sphinx when
-- | generating or verifying the proof, but can also be downloaded from our public S3 bucket:
-- |   https://sphinx-plonk-params.s3.amazonaws.com/v1.0.8-testnet.tar.gz
-- |   https://github.com/argumentcomputer/sphinx/blob/98d0d845d5f6397de226a8fd41590e228476ccdf/prover/src/install.rs#L14-L20
-- | You can also manually extract the downloaded tarball to `~/.sp1/circuits/plonk_bn254/v1.0.8-testnet`
-- |
-- | The bundled Makefile will compile the two components into static libraries in the current
-- | directory, then build this haskell program that verifies an example proof.
-- |
-- | Note: It's worth mentioning there is also `gnark-cli` crate which can also be used to verify proofs,
-- | located here: https://github.com/argumentcomputer/sphinx/blob/dev/recursion/gnark-cli/src/main.rs

module Main where

{-# LANGUAGE ForeignFunctionInterface #-}
{-# INCLUDE "babybear.h" #-}
{-# INCLUDE "libsphinxgnark.h" #-}

import Foreign.Ptr
import Foreign.C.String
import Foreign.C.Types

import System.Environment

-- These two are from `libbabybear.a`, and need to be imported so `libsphinxgnark.a` can make use of them.

-- uint32_t babybearextinv(uint32_t a, uint32_t b, uint32_t c, uint32_t d, uint32_t i);
foreign import ccall "babybearextinv" babybearExtInv :: CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> IO CUInt
-- uint32_t babybearinv(uint32_t a);
foreign import ccall "babybearinv" babybearInv :: CUInt -> IO CUInt

-- extern char* VerifyPlonkBn254(char* dataDir, char* proof, char* vkeyHash, char* commitedValuesDigest);
foreign import ccall "VerifyPlonkBn254" verifyPlonkBn254 :: CString -> CString -> CString -> CString -> IO CString

-- The version in the path below needs to match the version used to generate the proof.
-- This is the default install directory for the current dev version of Sphinx.
-- Note: This path is currently used by both SP1 and Sphinx, but the files are not interchangeable between implementations
plonkDataDir :: IO String
plonkDataDir = do
  home <- getEnv "HOME"
  return $ home ++ "/.sp1/circuits/plonk_bn254/v1.0.8-testnet"

-- Example proof used below, generated by the fibonacci example: https://github.com/argumentcomputer/sphinx/blob/dev/examples/fibonacci/script/bin/plonk_bn254.rs
--
-- To obtain these, an easy hacky way is to print out the values in this function: https://github.com/argumentcomputer/sphinx/blob/98d0d845d5f6397de226a8fd41590e228476ccdf/recursion/gnark-ffi/src/ffi/native.rs#L43-L48
--
-- The proof is a hex encoded string with no leading `0x`
-- The vkey hash and committed values digest are both string (decimal) representations of bigints of the corresponding hash values
--
-- TODO: Better wrappers for generating these strings.

main :: IO ()
main = do
  expandedPath <- plonkDataDir
  dataDir <- newCString expandedPath
  proof <- newCString "120872bef1950dd1904150f4164e45bbdd65deb5505e465ea15992d46b342294064a2b02d5b536a614199d129ac56656364eda7d196afcd0b421091a4451231022c8ce2c14a8685f0592f4db4f93c71917c1227850d115af58b1816359aa8d941b26790cf62a8480c2e5f773fb010204d1fef7f1bab93cf3ad73ced72d017c331599aa42a91eb5cd3a2e8d53129d59944c2fd6b14cdf02953eb32178b9faaf9328916ebd923eb3dd197e1b1e41a030f1a7d116c3db14cbc7b5dd19a632ad2564271f71820e0c53f1815a752f4626e66ee95e5abbe4e7c476eb3c6423bb16f66e2a0eed5a91a5ac4dacbf5713803d97f33d985c766e0b7845a83a3c7b614724ee13b59fe22ef48cb45e870ec462a8279658c5bae254eacbd087f826f94acfeec720d33092b8a34e23c509f4f52231cbac931a1d301f2384dccc2184a8da8733ce2c67586558d999ce0992c1b18e2f4ac703c9e39635f4872d6a8b67cf2b82291c0f13b1d8178840b23a2be2af61299ee52d696536cae22c7cf4b740aa28ef62782039ca4715cd18176c2ee392d777d6a4263a08423c37efce6d34eee233024c37149759ea1ada5ae9116d35478d7bcc272313b78e57063713cce17b5651398aef0edd36270b77baf9979475b953073be6318173845922b71a2c9dea1a42fcbbfa26af5ce0a87fc1aba8882363f1f63a25546e90ca750bcf84fd611a574643be29000000072a5856b99de4c0746a919e1ff82ba6d7355dfac8d38c67c7954ba3cb80298ecb057a67c31b2ba1fe4cdeea3e21221420924d31df35b3201f27215613f2e786141b90282e49a767b95fe712bf927dd409ac0e74a1d6a9b85241864fdd78d32b471708c5a8e3d7212a6275cf122f6c2dc3b4a6325dca561791ff212652a1fb7904179e2fb34991c0bf6700f75a5aa8f880e315e7fd387a28ff77b2af13f6cf7dcf10c1ec23c886f205913414975fe81c10fed5db3fd580faca76a5b48c998b89ac218c31efb7df05b7c0068923e42d371a71e9738d83f7b43357bf7eb6ac4cba541817d3089d38e9b4b26c3a13b792104113ba2ba6db4f8edc75ae2b2232ccefa0240ecfce2f67d246f6b269ff38a3136d49617b0be7b7bfe74f3d2bfe9ae6f4c613e554ad86b8920b37396e3884de51b57b55ea9ecf7d4bf08b2bbf23be2c41d2000000012897bc88671c2140f935cc250c36c6eced938e45879d4a62305a677f0e80b4c12547b49e6a1f738ae397636dba5553dc45fa5be795da174c94ee6d8011e246da"
  vkeyHash <- newCString "71660024445996800632758797160128461908903710453260780716051225259745518891"
  committedValuesDigest <- newCString "6265467995298269824615662043982564374977105610814771179903635896347370323221"
  rawRes <- verifyPlonkBn254 dataDir proof vkeyHash committedValuesDigest
  if rawRes == nullPtr
    then putStrLn "No errors, verification successful!"
    else do
      err <- peekCString rawRes
      putStrLn $ "Verification failed: " ++ err
